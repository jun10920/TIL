# Section08\_프록시와 연관관계 관리

## 프록시

- ex.find()
  - 데이터베이스를 통해서 실제 엔티티 객체 조회
- ex.getReference()
  - 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
- 특징
  - 실제 클래스를 상속
    - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨
  - 프록시 객체는 실제 객체의 참조를 보관
  - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드 호출
- 프록시 객체의 초기화
  - 프록시 객체는
    - 처음 사용할 때 한 번만 초기화
      - 초기화할 때 실제 인티티로 바뀌는 것이 아니라 프록시 객체를 통해서 실제 엔티티를 접근 가능한 것
    - 원본 엔티티를 상속받음
      - 타입 체크시 주의 (== 비교 대신 instance of 사용)
    - 영속성 컨텍스트에 이미 엔티티가 있으면 em.getReference()를 호출해도 실제 엔티티 반환
      - 반대로 프록시 객체가 이미 있어도 프록시를 반환
      - 영속성 상태에서 하나의 트랜잭션 안에서는 하나로 통일하려고 하기 때문
    - 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생
- 프록시 확인

## 즉시 로딩과 지연 로딩

**지연 로딩 LAZY를 사용해서 프록시로 조회**

- 만약 MEMBER와 TEAM을 같이 사용한다면?
- 즉시 로딩 EAGER를 사용해서 함께 조회(위에서 FetchType 조건만 바꾸면 된다)

### 프록시와 즉시로딩 주의

- 가급적 지연 로딩만 사용
  - 즉시 로딩을 적용하면 예상치 못한 SQL 발생
  - JPQL에서 N+1 문제를 일으킨다.
    - member에 엮인 team의 개수(n개) + member를 호출하는 쿼리 1개
  - @ManyToOne, @OneToOne 은 기본이 즉시 로딩
    - Lazy로 설정 필수
  - @OneToMany. @ManyToMany는 기본이 지연 로딩

### 정리

- 모든 연관관계에 지연 로딩을 사용해라
- 즉시 로딩과 비슷한 기능을 사용해야 하는 경우
  - JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라

## 영속성 전이(CASCADE)와 고아 객체

### 영속성 전이 CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용
  - 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장
- 연관관계 매핑이랑은 전혀 상관없음
-

### 고아 객체

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval = true
- `Parent parent1 = em.find(Parent.class, id);`
  `parent1.getChildrend().remove(0); // 자식 엔티티를 컬렉션에서 제거`
  - `DELETE FROM CHILD WHERE ID = ?`
- 주의
  - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체를 보고 삭제하는 기능
  - **참조하는 곳이 하나일 때 사용해야 함**
  - **특정 엔티티가 개인 소유할 때 사용**
  - 일대일, 일대다 관계만 가능
  - 고아 객체 제거 기능을 활성화
    - 부모를 제거할 때 자식도 함께 제거
    - CascadeType.REMOVE처럼 동작

### 영속성 전이 + 고아 객체, 생명주기

- **CascadeType.ALL + orphanRemoval=true**
  - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리 가능
  - 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용
