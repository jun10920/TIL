# Section03\_영속성 관리 - 내부 동작 방식

## 영속성 컨텍스트

### JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트
  - 특징
    - 엔티티를 영구 저장하는 환경
    - EntityManager.persist(entity);
    - 논리적인 개념
    - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
  - 이점
    - 1차 캐시
      - 엔티티매니저는 트랜잭션 단위로 생성되고 삭제되기 때문에 1차 캐시도 작은 부분을 담당
    - 동일성(identity) 보장
      - 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
    - 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)

    - 변경 감지(Dirty Checking)
      - 처음 저장할 때 캐시에 저장된 스냅샷과 비교해서 다르면 UPDATE SQL 생성
    - 지연 로딩(Lazy Loading)

## 플러시

영속성 컨텍스트이 변경내용을 데이터베이스에 반영

**특징**

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화하면 됨

**플러시 발생 시점**

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송

**영속성 컨텍스트를 플러시하는 방법**

- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

## 준영속 상태

- 영속 → 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함

**준영속 상태로 만드는 방법**

- **em.detach(entity)**
  - 특정 엔티티만 준영속 상태로 전환
- **em.clear()**
  - 영속성 컨텍스트를 완전히 초기화
- **em.close()**
  - 영속성 컨텍스트를 종료
