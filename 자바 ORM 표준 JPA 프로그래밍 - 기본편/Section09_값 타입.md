# Section09\_값 타입

## 기본값 타입

### JPA의 데이터 타입 분류

- 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능
    - 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
- 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
    - 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체
  - 값 타입 분류
    - 기본값 타입
      - 자바 기본 타입(int, double)
      - 래퍼 클래스(Integer, Long)
      - String
      - 생명 주기를 엔티티에 의존
        - 회원을 삭제하면 이름, 나이 필드도 함께 삭제
      - 값 타입은 공유하면 x
        - 회원 이름 변경시 다른 회원의 이름도 함께 변경되면 안됨
      - 참고
        - 자바의 기본 타입은 절대 공유 x
          - int, double 같은 primitive type은 절대 공유 x
          - 기본 타입은 항상 값을 복사함
          - Integer, String은 주소 값이 변경되므로 변경 x

## 임베디드 타입

### 임베디드 타입(embedded type, 복합 값 타입)

- 새로운 값 타입을 직접 정의할 수 있음
- JPA는 임베디드 타입이라 함
- 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고 함
- int, String과 같은 값 타입
- 예시
  - 회원 엔티티는
    - 이름
    - 근무기간(근무 시작일, 근무종료일)
    - 집 주소(주소 도시, 주소 번지, 주소 우편번호)를 가진다
- 임베디드 타입 사용법
  - @Embeddable: 값 타입을 정의하는 곳에 표시
  - @Embedded: 값 타입을 사용하는 곳에 표시
  - 기본 생성자 필수
- 장점
  - 재사용
  - 높은 응집도
  - Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메서드 만들 수 있음
  - 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존
- 속성 재정의
  - 한 엔티티에서 같은 값 타입을 사용할 때 → 컬럼 명이 중복되는 문제 발생
  - @AttributeOverrides, @AttributeOverride 사용해서 컬럼 명 속성을 재정의

## 값타입과 불변 객체

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험
  - side effect 발생
- 값 타입 복사
  - 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험
  - 대신 값(인스턴스)을 복사해서 사용
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0aaf4a74-921a-401b-8ef7-79a743f1e4df/47ef6dbb-6022-4e1f-bc25-d1b807b3852e/Untitled.png)
- 객체 타입의 한계
  - 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.
  - 임베디드 타입같이 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입
  - 객체 타입은 공유 참조를 피할 수 없다.
- 불변 객체
  - 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단
  - 값 타입은 불변 객체(immutable object)로 설계
  - 생성자로만 값을 설정하고 수정자를 만들지 않으면 됨
    - Integer, String은 자바가 제공하는 대표적인 불변객체

## 값 타입의 비교

값 타입은 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다.

- 동일성(identity) 비교: 인스턴스의 참조 값을 비교 / == 사용
- 동등성(equivalence) 비교: 인스턴스의 값을 비교 / equals() 사용
  - 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야 한다
  - 값 타입의 equals() 메서드를 적절하게 재정의(주로 모든 필드 사용)

## 값 타입 컬렉션

- 값 타입을 하나 이상 저장할 때 사용
  - 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.
  - RDB는 2차원 구조이므로 필드에 엔티티가 들어가면 2차원 이상의 구조가 되기 때문에 안된다
  - 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.
    - 상세설명
      PA에서 "컬렉션을 같은 테이블에 저장할 수 없다"는 표현은 값 타입 컬렉션(예: **`Set`**, **`List`**, **`Map`** 등의 자바 컬렉션에 저장되는 값 타입 객체들)을 엔티티의 일부로 사용할 때, 이 컬렉션에 속한 값 타입 객체들을 엔티티가 저장되는 기본 테이블에 직접 저장할 수 없다는 의미입니다. 대신, 이러한 컬렉션을 저장하기 위해 별도의 테이블을 사용해야 합니다. 이것은 데이터베이스의 관계형 모델이 컬렉션과 같은 다중성(multiplicity)을 직접적으로 표현할 수 없기 때문입니다.
      ### **값 타입 컬렉션 저장**
      - **`@ElementCollection`**: 이 어노테이션은 엔티티의 필드가 컬렉션임을 나타냅니다. 이 컬렉션에는 값 타입 객체들이 저장됩니다.
      - **`@CollectionTable`**: 이 어노테이션은 값 타입 컬렉션이 저장될 별도의 테이블을 지정합니다. 테이블 이름, 조인 컬럼(엔티티의 기본 키와 매핑되는 컬럼) 등을 지정할 수 있습니다.
      ### **예시**
      **`Employee`** 엔티티가 있고, 각 **`Employee`**는 여러 개의 **`Phone`** 번호를 가질 수 있다고 가정해 봅시다. 여기서 **`Phone`** 번호는 단순한 문자열 값(값 타입)이고, 한 **`Employee`**에 대해 여러 개의 **`Phone`** 번호가 존재할 수 있습니다.
      이 경우 **`Employee`** 엔티티의 테이블(**`EMPLOYEE`** 테이블)에 직접 **`Phone`** 번호들을 저장할 수 없습니다. 왜냐하면, 관계형 데이터베이스의 테이블은 2차원 구조이며, 각 행(row)은 하나의 엔티티 인스턴스를 나타내고, 각 열(column)은 그 엔티티의 단일 값 속성을 나타내기 때문입니다. 따라서, 하나의 행에 여러 **`Phone`** 번호(컬렉션)를 저장하는 것이 구조적으로 불가능합니다.
      이 문제를 해결하기 위해, **`Employee`** 엔티티와 관련된 **`Phone`** 번호들을 저장할 별도의 테이블(예: **`EMPLOYEE_PHONE`** 테이블)이 필요합니다. **`EMPLOYEE_PHONE`** 테이블은 **`Employee`**의 기본 키에 해당하는 외래 키 컬럼과, **`Phone`** 번호를 저장하는 컬럼을 포함할 것입니다. 이 구조를 통해, 한 **`Employee`**가 여러 개의 **`Phone`** 번호를 가질 수 있게 되며, 이 관계는 **`EMPLOYEE_PHONE`** 테이블에 의해 관리됩니다.
  - `@ElementColletion`
    - 이 어노테이션은 엔티티의 필드가 컬렉션임을 나타냅니다. 이 컬렉션에는 값 타입 객체들이 저장됩니다.
  - `@Collection Table 사용`
    - 이 어노테이션은 값 타입 컬렉션이 저장될 별도의 테이블을 지정합니다. 테이블 이름, 조인 컬럼(엔티티의 기본 키와 매핑되는 컬럼) 등을 지정할 수 있습니다.
- 값 타입 컬렉션도 지연 로딩 전략 사용
- 영속성 전이 + 고아 객체 제거 기능을 필수로 포함

### 값 타입 컬렉션의 제약사항

- 값 타입은 엔티티와 다르게 식별자 개념이 없다
  - 값은 변경하면 추적이 어렵다
- 값 타입 컬렉션에 변경 사항이 발생하면 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 함
  → null 입력x, 중복 저장x

### 정리

- 엔티티 타입의 특징
  - 식별자 O
  - 생명 주기 관리
  - 공유
- 값 타입의 특징
  - 식별자X
  - 생명 주기를 엔티티에 의존
  - 공유하지 않는 것이 안전(복사해서 사용)
    - 불변 객체를 만드는 것이 안전
- 값 타입은 정말 값 타입이라 판단될 때만 사용
  - 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안 됨
- 식별자가 필요하고 지속해서 값을 추적 변경해야 한다면 그것은 값 타입이 아닌 엔티티
