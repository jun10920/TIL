# Ch06 탐색

# 탐색 알고리즘의 개요

- 자료구조 형태에 따라 사용할 수 있는 여러 가지 탐색 알고리즘을 설명
  - 배열, 링크드 리스트, 이진 트리에 따라서 사용할 수 있는 알고리즘이 다름

# 순차 탐색

- 처음부터 끝까지 차례대로 모든 요소를 비교하여 원하는 데이터를 찾는 탐색 알고리즘
- 선형 탐색이라고도 불림(어느 한쪽 방향으로만 탐색할 수 있어서)
- 정렬되지 않은 데이터에서 원하는 항목을 찾을 수 있는 유일한 방법
- 구현이 간단해서 버그를 만들 가능성이 적음

## 자기 구성 순차 탐색

- 자기 구성법
  - 자주 사용되는 항목을 데이터 앞쪽에 배치함으로써 순차 탐색의 검색 효율을 끌어올리는 방법
  - 전진이동법, 전위법, 빈도 계수법이 존재

### 전진이동법

- 탐색된 항목을 데이터의 가장 앞(헤드)으로 옮기는 방법
- 한 번 찾은 대상을 다시 탐색할 때 바로 찾을 수 있음
- 특정 항목만 집중적으로 탐색 되는 현상이 모든 데이터에서 발생하지는 않음
- 한 번 탐색된 항목이 다음에 또 다시 검색될 가능성이 높은 데이터에 한해 사용

### 전위법

- 전위랑 위치를 바꾼다는 의미
- 탐색된 항목을 바로 이전 항목과 교환하는 전략을 취하는 알고리즘
- 자주 탐색된 항목을 조금씩 앞으로 옮겨서 전진이동법처럼 극단적이지 않음
- 하지만 처음부터 앞쪽에 위치한 요소는 계속 선두를 유지하고, 뒤에 있는 요소는 앞으로 오기가 힘들다는 단점이 있음

### 계수법

- 데이터 내 요소가 탐색된 횟수를 별도의 공간에 저장
- 탐색된 횟수가 높은 순으로 데이터를 재구성하는 전략의 알고리즘
- 전위법의 단점을 고치기는 했으나 계수 결과를 저장해야 하는 별도의 공간이 필요하고, 계수 결과에 따라 재배치해야 하는 등의 비용이 더 많이 소요

# 이진 탐색

- 정렬된 데이터 중 배열에서만 사용할 수 있는 고속 탐색 알고리즘

1. 데이터 중앙에 있는 요소를 선택
2. 중앙 요소값과 찾고자 하는 목표 값을 비교
3. 목표 값 < 중앙 요소 값 → 데이터 왼편을 탐색, 목표 값 > 중앙 요소 값 → 데이터 오른편을 탐색
4. 데이터를 찾을 때까지 반복

## 이진 탐색의 성능 측정

- 데이터의 크기를 n, 탐색 반복 횟수를 x번 해서 결국 데이터 범위의 크기를 1을 만든다고 가정

$$
1 = n*(1/2)^x
$$

$$
1=n*(1/2^x)
$$

$$
2^x=n
$$

$$
log_2n=x
$$

→ 이진 탐색의 최대 반복 횟수는 **log2의 n**이므로, 아무리 커져도 그 차이가 미미하다는 것을 의미한다.

# 이진 탐색 트리

- 이진 탐색을 위한 이진 트리
- 링크드 리스트와 같은 경우에는 헤드와 테일의 주소 값은 알아도 중앙 요소는 알 수 없어서 이진 탐색 트리를 사용
- 다른 트리와 다른 점은, 부모 노드의 왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 크다는 점

## 이진 탐색 트리의 기본 연산

### 이진 탐색 트리에서의 이진 탐색

- 각 노드가 이진 탐색을 하기 위한 중앙 요소의 역할을 한다는 것이 중요하다.
- 그래서 위에 설명한 이진 탐색의 방법대로 실행

### 노드 삽입 연산

- 이진 탐색하여 새 노드가 삽입될 곳이 어디인지 찾아내는 것

### 노드 삭제 연산

- 우선 삭제할 노드를 이진 탐색을 통해서 찾는다.
  - 삭제할 노드가 Leaf인 경우
    - 부모 노드에서 자식 노드의 포인터를 NULL로 처리하고, 삭제한 노드의 주소를 반환
  - 삭제할 노드가 자식이 있는 경우
    - 자식이 왼쪽, 오른쪽 중 하나만 있는 경우
      - 삭제할 노드의 자식을 삭제할 노드의 부모 노드에 연결하고 삭제
    - 양쪽 자식을 가진 경우
      - 삭제할 노드의 오른쪽 하위 트리에서 최솟값 노드를 삭제할 노드의 위치로 이동
      - 최솟값 노드의 오른쪽 자식을 최솟값 노드의 부모 노드와 연결

## 이진 탐색 트리의 문제점

- 한쪽으로만 기형적으로 하위 트리가 성장하면 검색 효율이 극단적으로 떨어짐

# 레드 블랙 트리

- 이진 트리와 거의 같지만 모든 노드가 빨간색 혹은 검은색이라는 차이점만 있다.
- 이진 트리에 더해 색깔을 나타내는 포인터와 부모를 나타내는 포인터(삽입, 삭제 시 사용)가 더 있다.

## 레드 블랙 트리의 구현 규칙

1. 모든 노드는 빨간색이거나 검은색이다
2. 뿌리 노드는 검은색이다
3. 잎 노드는 검은색이다
4. 빨간색 노드의 자식은 모두 검은색이다.
5. 뿌리 노드와 모든 잎 노드 사이에 있는 검은색 노드의 수는 모두 동일하다

- 레드 블랙 트리의 leaf 노드는 NIL 노드(센티넬 노드)이다.
  - NIL노드를 검은색으로 만들어서 Leaf로 만들면 2번 규칙을 항상 만족하기 때문이다.

## 레드 블랙 트리의 기본 연산

### 회전

- 부모와 자식의 노드 위치를 바꾸는 연산
- 우회전
  - 왼쪽 자식 노드의 오른쪽 자식 노드를 부모 노드의 왼쪽 자식으로 연결
- 좌회전
  - 오른쪽 자식 노드의 왼쪽 자식 노드를 부모 노드의 오른쪽 자식으로 연결

### 노드 삽입 연산

- 이진 트리의 삽입 연산과 거의 같으나 위배한 규칙들이 있는 지 확인하고 수정해야 한다.
- 새 노드를 삽입하면 이 노드를 빨간색으로 칠하고 NIL 노드를 양쪽 자식으로 연결
- 이때 유의해야 하는 규칙은 **‘빨간색 노드의 자식은 모두 검은색이다’**이다.
  - 삽입한 노드와 삽입한 노드의 부모가 모두 빨간색일 때를 의미
  - 이때는 삼촌 노드의 색에 따라 또 세 가지 경우로 나뉜다.
- **부모 노드 - 할아버지의 왼쪽 자식, 부모 노드와 새로운 노드 - 빨간색**
  - **삼촌 - 빨간색**
    - 부모 노드와 삼촌 노드를 검은색으로 칠하고 할아버지 노드를 빨간색으로 칠한다.
    - 이후 할아버지 노드를 새로 삽입한 노드로 간주하고 규칙을 위반하는지 확인
    - 이후 할아버지의 할아버지를 확인하는 등 반복해서 규칙을 만족할 때까지 반복
  - **삼촌 - 검은색, 새로 삽입한 노드 - 부모 노드의 오른쪽 자식**
    - 부모 노드와 새로 삽입한 노드를 좌회전 시켜 상황을 바꾸고, 부모 노드를 새로 삽입한 노드로 간주
    - 문제 상황을 바꾸기 위함이며, 현재 문제 상황은 삼촌-검은색, 새로 삽입한 노드가 부모의 왼쪽 자식인 경우이다.
  - **삼촌 - 검은색, 새로 삽입한 노드 - 부모 노드의 왼쪽 자식**
    - 부모 노드를 검은색, 할아버지 노드를 빨간색으로 칠하고 할아버지 노드와 부모 노드를 우회전
- 부모 노드가 할아버지의 오른쪽 자식이면 위의 세 가지 경우의 왼쪽과 오른쪽을 교체

### 노드 삭제 연산

- 이번에도 이진 트리의 삭제 연산과 과정은 거의 같으나 규칙에 위배되는 것을 확인 및 수정 필요
- 빨간색 노드 삭제의 경우
  - 어떤 규칙도 무너뜨리지 않는다.
- 검은색 노드 삭제의 경우
  - 4번 규칙 무너지는 경우도 있음
    - 삭제된 노드의 부모와 자식이 빨간색이면 4번 규칙이 무너짐
    - 이 경우 삭제된 노드를 대체하는 노드를 검은색으로 색칠하면 해결
  - 5번 규칙 무너짐
    - 경로에 있는 검은색의 수가 달라지기 때문
    - 새로 대체한 노드에 검은색을 덧칠함(이중 흑색 노드 생성)
    - 5번 규칙에서 1번 규칙이 무너진 것으로 상황이 바뀜
      - 이중 흑색 노드를 처리하는 방법은 이중 흑색 노드의 형제와 조카들의 상태에 따라 4가지로 나뉨
        - **형제가 빨간색인 경우**
          - 형제를 검은색, 부모를 빨간색으로 칠한다
          - 부모를 기준으로 자식 노드를 좌회전한다.
          - 그럼 형제가 검은색인 경우로 문제 상황이 바뀐다.
        - **형제가 검은색인 경우, 형제의 양쪽 자식이 모두 검은색인 경우**
          - 형제를 빨간색으로 칠하고, 이중 흑색 노드의 검은색 중 하나를 부모 노드에게 넘긴다.
          - 부모 노드가 넘겨 받은 검은색도 위의 문제 상황에 따라서 해결한다.
        - **형제가 검은색인 경우, 형제의 왼쪽 자식은 빨간색, 오른쪽 자식은 검은색인 경우**
          - 형제를 빨간색으로 칠하고, 왼쪽 자식은 검은색으로 칠하고, 형제 노드를 기준으로 우회전한다.
          - 이러면 형제-검은색, 형제의 오른쪽 자식 - 빨간색인 문제 상황으로 전환
        - **형제가 검은색인 경우, 형제의 오른쪽 자식이 빨간색인 경우**
          - 이중 흑색 노드의 부모 노드가 가지고 있는 색을 형제 노드에 칠한다
          - 부모 노드와 형제 노드의 오른쪽 자식 노드를 검은색으로 칠하고 부모 노드를 기준으로 좌회전 한다 (1번 규칙 만족)
          - 이후 이중 흑색 노드를 뿌리 노드에게 전달 (뿌리 노드는 이중 흑색 노드여도 그냥 검은색 한 개로 바꿔주면 문제 해결)
