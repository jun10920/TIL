# Ch01 리스트

# 리스트 ADT

## 개념

- 목록 형태로 이루어진 데이터 형식
- 목록을 이루는 개별 요소를 노드라고 지칭
- 첫 번째 노드는 **헤드**, 마지막 노드는 **테일**이라고 지칭
- 리스트의 길이는 헤드부터 테일까지 이르는 노드의 개수
- 갖춰야 할 일련의 연산은 **추가, 삽입, 제거, 삭제, 반환**

## 리스트와 배열의 비교

- 배열은 크기가 고정
- 리스트는 크기가 가변적

# 링크드 리스트

- 노드를 연결해 만든 리스트
- 데이터를 보관하는 **필드**와 다음 노드와 연결 고리 역할을 하는 **포인터**로 이루어짐

## 연산들은 책 참조 (26P~) / 이해하느라 고생한 부분들만 적음

```c
//노드 추가
void SLL_AppendNode(Node** Head, Node* NewNode){
    if((*Head)==NULL){
        *Head = NewNode;
    } else {
        Node* Tail = (*Head);
        while(Tail->NextNode!=NULL){
            Tail = Tail->NextNode;
        }
        Tail ->NextNode = NewNode;
    }
}
```

### 왜 Head의 매개변수가 이중 포인터인가?

- NewNode가 생성된 상태이고, Node\*_ Head 대신 Node_ Head가 매개변수로 전달됐다고 가정
  - 그럼 \*Head == NULL; 이므로 Head 포인터 변수가 아닌 Head 포인터의 값에 NewNode가 배정된다.
  - 우리가 원하는 건 Head 포인터로 전달되는 노드를 Head를 가리키게 하는 것인데, 이렇게 되면 계속 NULL 값을 가리키게 된다.

## 링크드 리스트의 장단점

- 장점
  - 노드의 추가, 삽입, 삭제 연산이 빠릅니다
- 단점
  - 매번 헤드부터 순차 탐색해야 하므로 탐색 비용이 매우 크며, 다음 노드를 가리키는 포인터 때문에 추가적인 메모리가 필요합니다.

→ 링크드 리스트는 레코드의 추가, 삽입, 삭제가 잦고 조회는 드문 곳에서 사용하면 좋다

→ 예시로 DB에서 조회해온 레코드를 순차적으로 다루는 데 제격

# 더블 링크드 리스트

- 링크드 리스트와 거의 같으나 양방향에 포인터가 있어 양방향으로 탐색이 가능하다

# 환형 링크드 리스트

- 헤드의 PreNode가 테일이고, 테일의 NextNode가 헤드인 리스트

### 장점

- 탐색할 때 헤드부터 마지막까지 모두 조회할 필요가 없어서 비용이 매우 감소한다
- 뒤에서부터 노드를 찾아가는 노드 탐색을 구현할 수도 있다.
