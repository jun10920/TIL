# Ch02 스택

# 스택 ADT

## 스택의 개념

- **LIFO(Last In-First Out):** 가장 마지막에 들어간 데이터가 제일 먼저 나온다.
- **FILO(First In-Last Out)**: 가장 먼저 들어간 데이터가 가장 나중에 나온다.
- 사용하는 곳
  - 힙 메모리(지역 변수), 네트워크 프로토콜, 컴파일러 구문 분석기, 편집 프로그램의 되돌리기에서 사용

## 스택의 핵심 기능

- **Push(**삽입 기능)
  - 스택 위에 새로운 노드 쌓기
- **Pop(**삭제 기능)
  - 스택에서 최상위 노드를 걷어 내기

# 배열로 구현하는 스택

- 장점
  - 구현이 간단하다
- 단점
  - 용량을 동적으로 변경하는 비용이 크다
- 노드를 동적으로 생성하고 제거하는 대신에, 스택 생성 초기에 사용자가 부여한 용량 만큼의 노드를 한꺼번에 생성
- 최상위 노드의 위치를 나타내는 변수를 두고 삽입과 제거 연산 수행

# 링크드 리스트로 구현하는 스택

- 장점
  - 스택 용량에 제한을 두지 않아도 된다
- 단점
  - 구현하기가 배열보다 복잡하다

# 스택의 응용: 사칙 연산 계산기

## 수식의 중위 표기법과 후위 표기법

- **역 폴리쉬 표기법**이라고도 불리며, 연산자가 피연산자 뒤에 위치한다는 규칙이 있다.
  - 일반적으로 우리가 사용하는 방법은 중위 표기법

## 후위 표기식을 계산하는 알고리즘

- 1 3 2 \* - 를 계산한다고 가정
- 스택에 1 → 3 → 2 순으로 쌓는다 (피연산자)
- 연산자 *를 만나면 스택에 쌓인 2, 3을 스택에서 제거하고 *연산한 값을 다시 스택에 쌓는다
  - 현재 스택 1 → 6
- 연산자 -를 만나면 스택에 쌓인 6, 1을 스택에서 제거하고 - 연산한 뒤 다시 스택에 쌓는다
  - 최종 스택 -5

## 중위 표기식을 후위 표기식으로 바꾸는 알고리즘

- **데이크스트라 알고리즘**
  - 입력 받은 중위 표기식에서 토큰을 읽음
  - 토큰이 피연산자라면 토큰을 출력
  - 토큰이 연산자(괄호 포함)이라면 스택의 최상위 노드에 담긴 연산자가 토큰보다 우선순위가 높은지 검사한다
    - 검사 결과가 참이면(토큰이 최상위 노드보다 우선순위가 높으면)
      - 최상위 노드 위에 토큰을 쌓는다.
    - 토큰이 최상위 노드보다 우선순위가 낮으면
      - 최상위 노드를 출력한다
    - 위 과정을 반복한다
  - 토큰이 오른쪽 괄호면 최상위 노드에 왼쪽 괄호가 올 때까지 스택에 제거 연산을 수행하고 제거한 노드에 담긴 연산자를 출력한다. 왼쪽 괄호를 만나면 제거만 하고 출력하지는 않는다.
