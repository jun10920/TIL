# Ch10 문자열 탐색

# 문자열 탐색 알고리즘

- 본문
  - 탐색 대상이 되는 문자열
- 패턴
  - 탐색어
- 이동
  - 본문에서 탐색 위치를 옮기는 일

# 고지식한 탐색 알고리즘

## 동작 방식

- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내 문자들을 일일이 비교하는 방식으로 동작
- 본문 길이를 N, 패턴 길이를 M이라고 했을 때 최악의 경우 N\*M번 비교를 수행
  - 각 본문의 문자마다 패턴의 모든 문자를 비교하는 경우

# 카빈 - 라프 알고리즘

## 동작 방식

- 문자열 탐색을 위해 해시 함수를 사용
  - 패턴의 해시값과 본문 내의 하위 문자열들의 해시값들을 비교하는 방식
- 해시 함수 (S는 문자열, S[n]은 문자열 내의 N번째 문자, m은 문자열의 길이)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0aaf4a74-921a-401b-8ef7-79a743f1e4df/66d2fbe2-e8a8-4a60-b91c-05557ce31bf9/Untitled.png)

- i가 0일 때
  - 이전 해시 값이 없으므로 위의 식을 사용
- 그 외의 경우
  - 이전 해시 값을 이용해서 간단하게 구할 수 있음, 본문의 길이에만 영향을 받음
- 해시값을 이용하므로 충돌의 위험이 있음
  - 해시값이 같은 문자열을 본문에서 찾아낸 다음에 실제로 각 문자가 패턴의 문자와 일치하는지 한 차례 더 확인

# KMP 알고리즘

- 고지식한 탐색 알고리즘처럼 왼쪽에서 오른쪽으로 문자를 비교하지만 비교할 필요가 없는 부분은 지나치고 탐색하는 알고리즘
- 본문 내 문자열을 한 번 비교하면 다음 탐색에서 사용할 정보가 남고, 이 정보를 사용하면 불필요한 비교를 안 할 수 있다는 원리를 이용한 방식

### 명칭 정리

- 접두부
  - 문자열의 머리 부분
- 접미부
  - 문자열의 꼬리 부분
- 빈 문자열도 접두부와 접미부가 될 수 있다.
- 경계
  - 일치하는 접두부와 접미부 쌍

## 동작 방식

1. 왼쪽부터 문자열을 탐색하다가 불일치를 발견
2. 불일치 전까지 일치했던 본문과 패턴의 문자열 확인
3. 경계를 찾는다
4. 접미부에 접두부의 위치를 이동 시키기 위해서 (일치하는 부분 문자열의 길이 - 접두부(집미부)의 길이)만큼 패턴을 오른쪽으로 이동 시켜서 탐색을 시작한다.

- 최악의 경우여도 본문의 길이 n일 때 n번만큼 비교를 수행하면 일치하는 문자열 탐색 가능
  - 계속 불일치여서 한 글자씩 이동해도 n번만 비교하면 됨

## 경계 정보 사전 계산 방법

- 경계에 대한 정보를 매 탐색마다 하면 비용이 많이 듬
- 그래서 미리 경계에 대한 정보를 가진 테이블을 생성

테이블 예시

| 일치 접두부의 길이 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ------------------ | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 문자열             | B   | A   | A   | B   | A   | B   | A   | A   |     |

| 일치 접두부의
최대 경계 너비 | -1 | 0 | 0 | 0 | 1 | 2 | 1 | 2 | 3 |

- 첫 번째 문자는 이전 접두부가 없어서 항상 최대 경계 너비가 -1
  - 0은 일치 접두부가 있지만 경계가 없는 경우를 의미해서 -1
- 첫 번째 문자는 일치하지만 두 번째 문자부터 불일치 하는 경우
  - 일치 접두부는 존재하지만 문자열에서 경계는 존재하지 않으므로 너비는 0
- 2, 3 번째 문자까지 일치한 경우도 마찬가지
- 4번째 문자까지 일치한 경우
  - BAAB에서 최대 경계 B가 존재하므로 너비는 1
  - 같은 방식으로 뒤도 채우면 된다.
- 문자열의 길이보다 테이블의 길이가 1 크다
  - 본문 내 문자열이 패턴과 일치하지만 이어서 탐색하고 할 때 사용하기 위함
- 이동 거리 = 일치 접두부의 길이 - 최대 경계 너비

# 보이어 - 무어 알고리즘

- 패턴의 오른쪽 끝에 있는 문자와 본문의 문자가 불일치 한 경우
  - 불일치 한 본문의 문자가 패턴 내에 존재하지 않는 경우
    - 이동 거리 = 패턴의 길이
  - 불일치 한 본문의 문자가 패턴 내에 존재하는 경우
    - 나쁜 문자 이동
    - 착한 접미부 이동

## 나쁜 문자 이동

- 나쁜 문자
  - 본문과 패턴을 불일치하게 만드는 본문의 문자
- 작동 방식
  | B   | A   | A   | B   | A   |     |
  | --- | --- | --- | --- | --- | --- |
  | B   | B   | A   | C   |     |     |
  |     | →   | B   | B   | A   | C   |

1. 본문과 패턴을 오른쪽부터 비교하다가 불일치가 발생
2. 본문의 불일치한 문자와 같은 불일치 문자를 패턴의 왼쪽부터 찾는다.
3. 찾아낸 패턴의 불일치 문자 위치가 본문의 불일치 문자 위치와 일치하도록 패턴을 뒤로 이동
   1. 패턴의 불일치 문자가 여러 개라면 가장 오른쪽에 있는 것과 본문과 맞춤

- 실패하는 경우
  |     |     | B   | A   | A   | B   | A   |
  | --- | --- | --- | --- | --- | --- | --- |
  |     |     | A   | B   | A   | B   |     |
  |     | B   | B   | A   | C   | ←   |     |
  - 본문의 불일치 문자 위치보다 패턴에서 불일치 문자 위치가 뒤면 오히려 패턴을 앞으로 이동
  - 이런 경우 사용하는 게 착한 접미부 이동

## 착한 접미부 이동

- 착한 접미부
  - 일치하는 접미부
- 착한 접미부가 존재하는 경우는 두 가지
  - 불일치 발생했을 때 착한 접미부가 패턴의 불일치 지점 이전에 존재하는 경우
    - 찾아낸 패턴의 부분을 착한 접미부 위치와 일치하도록 패턴을 이동
  - 첫 번째 경우가 만족하지 않는 경우는 착한 접미부의 접미부가 패턴의 접두부와 일치하는지 확인
    - 패턴의 접두부가 착한 접미부의 접미부와 일치하도록 패턴을 이동
  - 두 가지 경우에 다 해당하지 않는 경우
    - 그냥 패턴의 길이만큼 오른쪽으로 이동

## 보이어 - 무어 알고리즘의 전처리 과정

- 경계 정보 때와 마찬가지로 ‘나쁜 문자 이동 테이블’과 ‘착한 접미부 이동 테이블’을 이용

### 나쁜 문자 이동 테이블 만들기

1. 모든 문자가 입력할 수 있는 있는 테이블 생성(예시/ index:ASCII 코드, data)
2. 패턴을 왼쪽 → 오른쪽으로 읽어나가면서 패턴에 있는 각 문자의 위치를 테이블에 기록
3. 중복 해서 나오는 문자들은 덮어쓰기로 작성
   1. 가장 오른쪽에 등장한 문자의 위치만 테이블 남음
4. 테이블에 입력된 위치는 불일치가 발생했을 때의 이동 거리에 참조

### 착한 접미부 이동 테이블 만들기

- 경우가 두 가지인 만큼 테이블도 두 가지를 고려해서 만듬
- 일치 발생했을 때 착한 접미부가 패턴의 불일치 지점 이전에 존재하는 경우
  1. 패턴의 길이 + 1 크기의 테이블 생성
  2. 패턴을 오른쪽에서 왼쪽으로 읽으면서 나타나는 접미부 X를 경계로 가진 패턴 내 가장 큰 하위 문자열 Y를 찾음
  3. X의 시작 위치 - Y의 시작 위치를 이동 거리로 입력
  - X가 다른 문자열과 경계를 이룰 수 없거나 (접미부의 길이가 패턴 길이의 1/2을 넘는 경우), 경계가 되더라도 왼쪽으로 확장해서 더 큰 경계가 될 수 있는 경우 이동 거리 항목 0처리

예시) AABABA 패턴으로 착한 접미부 이동 테이블 만들기

| 접미부의 시작 위치                  | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----------------------------------- | --- | --- | --- | --- | --- | --- | --- |
| 문자열                              | A   | A   | B   | A   | B   | A   |     |
| 접미부의 가장 넓은 경계의 시작 위치 | 5   | 3   | 4   | 5   | 6   | 6   | 7   |
| 이동 거리                           | 0   | 0   | 0   | 2   | 0   | 4   | 1   |

- 빈 접미부(’ ‘)는 경계를 이룰 수 없으므로 경계의 시작 위치: 패턴 길이+1, 이동 거리: 1
- 접미부의 시작 위치 5인 A의 경우
  - A를 경계로 가진 접미부: ABA, ABABA, AABABA
  - 패턴의 시작 부분을 가지고 있는 경우는 두 번째 경우로 넘김
  - 가장 큰 하위 문자열 Y: ABABA
  - X - Y = 5 - 1 = 4
  - A 자체는 경계를 갖지 않으므로 경계의 시작 위치: 패턴 길이인 6
- 접미부의 시작 위치 4인 BA의 경우
  - BA를 경계로 가진 가장 큰 하위 문자열 Y: BABA
  - 왼쪽으로 확장한 ABABA가 ABA를 경계로 가지고 있음
  - 이동 거리 0 처리
  - BA 자체는 경계가 없으므로 경계의 시작 위치: 패턴 길이인 6
- 접미부의 시작 위치 3인 ABA의 경우
  - ABA를 경계로 갖는 가장 큰 하위 문자열 Y: ABABA
  - X - Y = 3 - 1 = 2
- 접미부의 시작 위치1, 2, 3인 경우
  - 이미 접미부의 길이가 패턴의 길이의 절반보다 크기 때문에 이동 거리를 0으로 채운다.

이동 거리 0인 항목들 처리 방법

| 접미부의 시작 위치                  | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----------------------------------- | --- | --- | --- | --- | --- | --- | --- |
| 문자열                              | A   | A   | B   | A   | B   | A   |     |
| 접미부의 가장 넓은 경계의 시작 위치 | 5   | 3   | 4   | 5   | 6   | 6   | 7   |
| 이동 거리                           | 5   | 5   | 5   | 2   | 5   | 4   | 1   |
| 접미부의 길이                       | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| 경계의 너비                         | 1   | 2   | 2   | 1   | 0   | 0   | 0   |

1. 첫 접미부의 가장 넓은 경계의 시작 위치’ 를 이동 거리로 입력
2. 경계의 너비보다 접미부가 짧아지기 전까지 나타나는 모든 경계는 동일한 이동 거리 입력
3. 경계의 너비보다 접미부가 짧아지면 ‘접미부의 시작 위치 -1’에 있는 ‘접미부의 가장 넓은 경계의 시작 위치’를 이동 거리로 입력한다.
