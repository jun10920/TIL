# Ch05 정렬

# 정렬 알고리즘의 개요

- 정렬이란 정해준 기준에 따라 데이터를 순서대로, 체계적으로 정리하는 알고리즘
- 정리하는 목적은 **탐색**

# 버블 정렬

- 물 속 깊은 곳에서 수면을 향해 올라오는 거품의 모습처럼 데이터를 정렬
  - 이를 반대로 뒤집으면 가라앉는 것처럼 보여서 싱킹 정렬이라고도 부른다.
- 자료구조를 순회하면서 이웃한 요소들끼리 데이터를 교환하면서 정렬을 수행

## 버블 정렬의 성능 측정

- 버블 정렬은 자료구조를 한 번 순회할 때(한 번 순회할 때마다 가장 큰 값이 가장 위에 놓임) 자료구조의 범위가 하나씩 줄어든다.
- n개의 자료구조는 (n-1) ~ 1번 순회해야한다.
- 이를 다 더하면 n(n-1)/2 번 순회해야한다.

# 삽입 정렬

- 자료구조를 순회하면서 순서에 어긋나는 요소를 찾고, 그 요소를 올바른 위치에 다시 삽입해나가는 정렬 알고리즘

## 삽입 정렬 과정

1. 자료구조에서 정렬 대상이 될 범위를 지정 (처음에는 2개의 요소로 시작하며 1개씩 증가한다, ‘최대 알고리즘의 -1’까지 증가)
2. 범위 선정 후 범위 마지막에 있는 요소가 정렬 요소 중에 가장 큰 지 확인
3. 가장 크면 가만히 냅두고, 크지 않다면 마지막에 있었던 요소와 첫 요소 사이의 요소 중에 순서에 맞는 위치를 찾음
4. 위치를 찾으면 이동한 요소보다 큰 요소들은 모두 한 자리씩 이동
5. 이를 반복

## 삽입 정렬의 성능 측정

- 버블 정렬은 정렬되어 있든 안되어 있든 모두 순회하므로 n(n-1)/2번 순회한다.
- 삽입 정렬은 정렬이 되어있는 경우에는 비교를 하지 않기 때문에 최선의 경우 한 번만 확인하는 n-1 번만 순회한다.
- 그럼 평균적인 성능은 n(n-1)/2와 (n-1)의 평균인 (n^2+n-2)/2이다 → 대충 버블 정렬보다 조금 더 낫다는 뜻

# 퀵 정렬

- 전쟁 전략인 분할 정복에 바탕을 둔 알고리즘
  - 적군 전체를 공략하는 대신에 적군을 잘게 나누어 공략하는 전법

## 퀵 정렬 과정

1. **기준 요소 선정 및 정렬 대상 분류**
   1. 기준 요소(Pivot)를 선정하고 이보다 작은 값은 기준 요소의 왼쪽으로, 큰 값은 오른쪽으로 이동
2. **정렬 대상 분할**
   1. 왼쪽, 오른쪽 그룹을 분할하여 각 그룹에 대해 1의 과정을 수행
3. **반복**
   1. 그룹의 크기가 1 이하여서 더 이상 분할할 수 없을 때까지 1과 2의 과정을 반복

- 기준 요소 선택이 성능의 중요한 요소
  1. 난수를 생성해 기준 요소를 선택
     1. 최솟값이나 최댓값이 선택되는 확률을 크게 줄일 수 있음, 하지만 난수 생성 과정에서 성능이 저하
  2. 처음 3개 요소 중 중간 값을 기준 요소로 선정
     1. 중간 값을 구하는 과정에서 성능이 저하되지만 항상 최악의 경우를 피할 수 있음

## 퀵 정렬 전 고려해야할 문제 2가지

1. 분할 과정을 어떻게 효율적으로 처리할 것인가?
   1. 수색 섬멸 작전 실시
      1. 왼쪽부터 순회하면서 기준보다 큰 요소를 찾기
      2. 동시에 오른쪽부터 순회하면서 기준보다 작은 요소 찾기
      3. 두 요소의 자리를 교환하고 두 요소가 맞붙을 때까지 1~2 과정을 반복하기
      4. 마지막에 오른쪽 요소와 기준 요소의 자리를 바꾸기
2. 반복되는 분할 과정은 어떻게 처리할 것인가?
   1. 재귀 호출을 사용하기

## 퀵 정렬의 성능 측정

- 기준 요소 선정, 분할의 반복이 중요한 요소
- 기준 요소는 첫 번째 요소로 하기로 했으니까 고려의 대상에서 제외
- 분할의 반복을 성능 측정하기 위해선 두 가지를 고려
  - 재귀 호출의 깊이
  - 분할을 위한 비교 횟수
- 최선의 경우
  - 한 번 호출될 때마다 자료구조의 크기가 1/2로 쪼개지는 것을 의미한다.
  - 자료구조의 크기가 n일때, 퀵 정렬의 호출길이는
  $$
  log_2n
  $$
  - 비교는 깊이와 상관없이 n 번이므로, 최선의 경우 퀵 정렬의 성능은
  $$
  n*log_2n
  $$
- 최악의 경우
  - 매번 분할이 1:(n-1)로 되는 경우를 말하며, 이러면 매번 범위가 1씩 줄어든다.
  - 그럼 깊이는 n-1이 되고, 이때 비교도 n-1부터 1번하니까
  - 1, 2…n-1을 모두 합치면 버블 정렬과 마찬가지로 **n(n-1)/2**의 성능이 나온다.
- 평균의 경우

$$
1.39*nlog_2n
$$

- 이는 최선의 경우에 비해서 39% 느린 성능이다.
