# Ch12 분할 정복

# 분할 정복 알고리즘의 개념

- 문제를 더 이상 나눌 수 없을 때까지 나누고, 이렇게 나뉜 문제들을 각각 풀어 결국 전체 문제의 답을 얻는 기법

## 분할 정복 알고리즘 절차

1. 분할
   1. 문제가 분할 가능한 경우 2개 이상의 하위 문제로 나눈다.
2. 정복
   1. 하위 문제가 여전히 분할 가능한 상태라면 하위 집합에 대해 단계 1을 수행한다. 그렇지 않다면 하위 문제를 푼다.
3. 결합
   1. 단계 2를 통해 구한 답을 취합한다.

- 나누는 방법과, 취합해서 병합하는 방법이 중요

# 병합 정렬

## 병합 정렬 동작 방식

1. 정렬할 데이터를 반으로 나눈다
2. 나뉜 하위 데이터의 크기가 2 이상이면 이 하위 데이터에 대해 단계 1을 반복한다
3. 동일 데이터에서 나뉜 하위 데이터 둘을 병합하여 원래 하나의 데이터로 만든다.
   1. 병합할 때 데이터의 원소는 정렬 기준에 맞춰서 정렬하여 병합한다.
      1. 정렬과정
         1. 두 데이터를 합한 것만큼 비어있는 데이터 공간을 마련한다.
         2. 두 데이터의 첫 번째 요소를 비교하여 작은 요소를 새 데이터에 추가
         3. 추가된 요소는 원래의 데이터에서 삭제
         4. 양쪽 데이터가 빌 때까지 단계 2를 반복
4. 데이터가 원래대로 하나의 데이터가 될 때까지 3 과정을 반복한다.

# 거듭 제곱 계산

- 거듭 제곱 코드

```c
int power(int Base, int Exponent){
	int i=0;
	int Result=1; // C^0은 1

	for(i=0; i<Exponent; i++){
		Result *= Base;
	}
	return Result;
}
```

- 이 거듭 제곱 코드의 시간 복잡도는 O(n)
  - Exponent(지수)의 크기만큼 계산해야 하기 때문이다.
- 하지만 분할 정복을 이용하면 시간 복잡도를 O(log_2n)으로 줄일 수 있다.
  - C^8을 연산할 때 단순히 C에 C를 7번 곱하는 방법도 있지만
  - C^2을 세 번 연산하는 방법도 있다. (총 3번)
    - 지수가 홀수인 경우는 C^((n-1)/2)*C^((n-1)/2)*C
    - 지수가 짝수인 경우는 C^(n/2)\*C^(n/2)
  - 지수를 반으로 나눠가는 알고리즘이므로 시간 복잡도는 O(log_2n)이다.

# 분할 정복 기반 피보나치 수 구하기

## 피보나치 수를 구하는 방법

- 피보나치 수 공식 F(n)
  - n=0, 0
  - n=1, 1
  - n>1, F(n-1)+F(n-2)

```c
ULONG Fibonacci(int n){
	if(n==0)
		return 0;
	if(n==1||n==2)
		return 1;

	return Fibonacci(n-1)+Fibonacci(n-2);
}
```

- 하지만 보다시피 하나의 계산에 두 개의 계산으로 나뉘므로, 시간 복잡도가 O(2^n)이다
- 분할 정복을 이용하면 이것도 O(log_2n)으로 획기적으로 줄일 수 있다.
- 이는 행렬을 이용해야 하는데 자세한 건 교재 539p를 참고해라
