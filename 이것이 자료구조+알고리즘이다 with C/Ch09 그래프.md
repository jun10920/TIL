# Ch09 그래프

# 그래프의 개요

## 그래프의 정의

- G = (V, E) / 그래프 = G, 정점의 집합 = V, 간선의 집합 = E
  - 간선의 종류
    - 진입 간선
      - 정점으로 들어가는 간선
    - 진출 간선
      - 정점에서 나가는 간선
- 방향성 그래프
  - 간선에 방향성이 있는 그래프
- 무방향성 그래프
  - 간선에 방향성이 없는 그래프
- 관계
  - 정점들 사이에 간선이 연결되면서 생기는 것
  - 인접/이웃관계
    - 간선으로 연결된 두 정점을 의미
- 경로
  - 한 정점에서 다른 정점으로 가는 길의 정점 집합
- 길이
  - 정점과 정점 사이의 간선의 수
- 사이클
  - 다시 출발했던 곳으로 돌아갈 수 있는 경로
- 연결성
  - 무방향성 그래프 내의 두 정점 사이에 경로가 존재하면 연결되어있고 지칭
  - 그래프가 연결되어있다.
    - 각 정점이 다른 모든 정점과 연결되어있는 경우를 의미

# 그래프 표현 방법

## 인접 행렬

- 그래프의 정점 수를 N이라고 했을 때, N\*N 행렬을 만들어 한 정점과 다른 정점이 인접해 있는 경우 행렬의 원소를 1, 아니면 0이라고 표현하는 것
- 무방향성 그래프의 경우
  - 주대각선(왼쪽 위에서 오른쪽 아래를 가로지르는 선)을 기준으로 대칭
- 방향성 그래프의 경우
  - 진출 간선으로 가리키고 있는 정점에 대해서만 인접해 있다고 표현하기 때문에 대칭 X

## 인접 리스트

- 모든 정점들을 늘어놓고 각 정점의 인접 정점을 옆에 나열하는 것
- 인접 정점들끼리 리스트로 연결한 후 이를 각 정점에 연결

## 인접 행렬과 인접 리스트의 비교

- 인접 행렬
  - 정점 간의 인접 여부를 빠르게 알 수 있다.
  - 메모리의 양이 정점의 크기에 제곱만큼 커진다.
- 인접 리스트
  - 정점과 간선의 삽입이 빠르고 메모리의 양이 적다.
  - 정점 간의 인접 여부를 알아내기 위해서 정점의 인접 리스트를 타고 순차 탐색을 해야 한다

# 그래프 표현 방법

## 깊이 우선 탐색(DFS)

- 더 이상 탐색할 다음 정점이 없을 때까지 진행한다는 원칙으로 순회하는 알고리즘

1. 시작 정점을 밟은 후 이 정점을 ‘방문했음’으로 표시
2. 이 정점과 이웃 정점 중에 아직 방문하지 않은 곳을 선택하여 이를 시작 정점으로 삼고 다시 1~2단계 반복
3. 더 이상 방문하지 않은 이웃 정점이 없으면 이전 정점으로 돌아가 2번 실행
4. 이전 정점으로 돌아가도 더 이상 방문할 이웃 정점이 없다면 그래프의 모든 정점을 방문했다는 의미이므로 탐색 종료

## 너비 우선 탐색(BFS)

- 깊이를 한 단계씩 더해가며 해당 깊이 있는 모든 정점을 방문하고 더 이상 방문할 정점이 없으면 탐색 종료

1. 시작 정점을 ‘방문했음’으로 표시하고 큐에 삽입
2. 큐로부터 정점을 제거, 제거한 정점의 인접 정점들에게 이동해 1번 과정 실행
3. 큐가 빌 때까지 탐색

# 위상 정렬

- 위상이란?
  - 어떤 사물이 다른 사물과의 관계 속에서 가지는 위치나 상태
  - 위상 정렬에서의 위상
    - 어떤 정점이 다른 정점과 관계 속에서 가지는 위치나 상태
- 간선을 뻗어내는 정점이 앞, 간선을 받아들이는 정점이 뒤인 상황에서 앞/뒤 관계를 정렬하는 것

## 위상 정렬의 동작 방식

- 조건
  - DAG(Directed Acyclic Graph)
    - 그래프에 방향성이 존재
    - 그래프 내에 사이클이 없어야 함

### 일반적인 경우

1. 리스트를 하나 준비
2. 그래프에서 진입 간선이 없는 정점을 리스트에 추가하고 해당 정점 자신과 진출 간선을 제거
3. 모든 정점에 대해 2를 반복하고 그래프 내에 정점이 남아 있지 않으면 정렬을 종료
4. 리스트에 위상 정렬된 그래프가 저장

### 깊이 탐색을 이용하는 경우

1. 리스트를 하나 준비
2. 그래프에서 진입 간선이 없는 정점에 대해 깊이 우선 탐색을 시행
3. 탐색 중에 더 이상 옮겨갈 수 있는 인접 정점이 없는 정점을 이 정점을 리스트의 새로운 헤드로 입력
4. 3을 반복하다가 더 이상 방문할 정점이 없으면 깊이 우선 탐색을 종료
5. 리스트에 위상 정렬된 그래프가 저장

# 최소 신장 트리

- **가중치**
  - 간선에 새로 부여하는 속성으로, 여러가지 의미를 담을 수 있다.
- **신장 트리**
  - 그래프의 모든 정점을 연결하는 트리
  - 그래프의 하위 개념
- **최소 신장 트리(최소 가중치 신장 트리)**
  - 여러 간선 중에서 가중치의 합이 최소가 되는 간선만 남긴 신장 트리
  - 사용 예시
    - 최소한의 비용으로 모든 도시를 연결하는 도로를 건설하는 방법 찾기
    - 최소 비용으로 새로 건설한 호텔의 배관을 구축할 방법 찾기
    - 최소한의 노력으로 전기선 연결 작업을 마무리할 방법 찾기
- 조건
  - CWG(Connected Weighted Graph)
    - 연결된 가중치 그래프

## 최소 신장 트리를 구현하는 알고리즘

### 프림 알고리즘

- 로버트 프림이 고안한 그래프에서 최소 신장 트리를 만들어 내는 알고리즘
- 진행하면서 가중치를 조사하고 추가하는 방식

1. 그래프와 최소 신장 트리를 준비 (최소 신장 트리에는 아직 아무 노드가 없음)
2. 그래프에서 임의의 정점으로 선택하여 최소 신장 트리의 뿌리 노드로 삽입
3. 뿌리 노드의 인접 정점들의 간선을 조사, 간선 중에 가장 가중치가 작은 것을 골라 이 간선에 연결된 정점을 최소 신장 트리에 삽입
   1. 이때 기존 노드와 사이클을 형성해서는 안됨
4. 3의 과정을 반복하다가 모든 정점을 연결하면 종료

**해결해야 할 부분**

1. 어떤 자료구조를 최소 신장 트리에 사용할 것인가
2. 간선 중에서 최소 가중치를 가진 간선을 탐색하는 과정의 비용
   1. 정점을 추가할 때 마다 모든 정점을 순회하면서 이 정점이 이미 추가되었는지 확인(N번)하고, 모든 간선을 확인해서 최소 가중치를 갖는지도 확인(N번)해야 한다. 총 N의 제곱 번
      1. 이를 위해서 우선 순위 큐를 사용하는 것이 바람직함

### 크루스칼 알고리즘

- 그래프 내 모든 간선의 가중치 정보를 사전에 파악하고 이 정보를 토대로 최소 신장 트리를 구축

1. 그래프 내의 모든 간선을 가중치의 오름차순으로 정렬하여 목록을 만든다.
2. 1에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가
   1. 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안된다.

해결해야 할 부분

- 최소 신장 트리에 생기는 사이클을 어떻게 감지할 것인가?
  - 프림의 경우 가중치를 조사하고 선택하면서 트리를 유지하며 진행하기 때문에 사이클 조사가 필요 없다.
  - 크루스칼 알고리즘은 간선 들을 하나씩 추가하면서 사이클 검사를 하고 통과되면 최소 신장 트리에 추가한다.
  - 해결 방법
    1. 깊이 우선 탐색
       1. 이미 방문했던 노드를 또 만난다면 사이클 생성됐다고 판정
    2. 분리 집합
       1. 각 정점 별로 분리 집합을 형성하고 정점끼리 연결할 때 합집합 연산을 함
       2. 새로운 정점을 추가할 때 같은 집합에 있는지 확인하면 사이클 형성 여부 확인 가능

# 최단 경로 탐색: 데이크스트라 알고리즘

## 데이크스트라 알고리즘의 개념

- 프림 알고리즘과 비슷하나 프림 알고리즘은 간선의 가중치를 이용해서 선택하지만 데이크스트라 알고리즘은 경로의 길이를 이용해서 간선을 선택

조건

- 사이클이 없는 방향성 그래프에서만 사용 가능

1. 각 정점에는 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 준비하고 각 정점에 대한 경로의 길이를 무한대로 초기화
2. 시작 정점의 길이를 0으로 초기화하고 최단 경로에 추가
3. 최단 경로에 새로 추가된 정점의 인접 정점에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가
   1. 만약 추가하려는 인접 정점이 이미 최단 경로에 있다면 갱신 되기 이전의 경로 길이가 새로운 경로 길이보다 더 큰 경우에 한해 기존 경로에서 현재 정점을 지나는 경로로 수정
4. 그래프 내의 모든 정점이 최단 경로에 추가될 때까지 3의 과정을 반복
