# PART 03 포인터와 배열의 완성

# ch16 다차원 배열

## 다차원 배열의 이해와 활용

### 다차원 배열 == 2, 3차원 배열

- C언어의 문법은 4차원 이상의 배열 선언을 문법적으로 허용
- 하지만 불필요+논리적으로 이해하기 어려움 → 다차원 배열은 2, 3차원 배열을 의미한다고 해석
- 대부분은 2차원 배열을 의미

### 2차원 배열의 선언

```c
TYPE arr[행][열] // 배열의 이름이 arr, 배열 요소의 자료형이 TYPE인 경우
```

### 2차원 배열 요소의 접근

```c
arr[N-1][M-1]=20; // 세로 N, 가로 M의 위치에 정수 20을 저장
printf("%d", arr[N-1][M-1]); // 세로 N, 가로 M의 위치에 저장된 값 출력
```

### 2차원 배열의 메모리상 할당의 형태

- 컴퓨터의 메모리는 1차원 구조
- 2차원 배열 역시 1차원 구조로 저장되어 있다.
- int형 배열의 요소 별 주소 값은 int형 변수의 크기인 4바이트만큼 차이가 난다.

### 2차원 배열 선언과 동시에 초기화

1

```c
int arr[3][3] = {
	{1, 2, 3},
	{4, 5, 6},
	{7, 8, 9}
};
```

2

```c
int arr[3][3] = {
	{1},
	{4, 5},
	{7, 8, 9}
};
// 빈 영역은 0으로 초기화
```

3

```c
int arr[3][3] = {
	1, 2, 3,
	4, 5, 6,
	7, 8, 9
};
==
int arr[3][3] = {1,2,3,4,5,6,7,8,9};
```

### 배열 크기를 정하지 않고 초기화

- 행의 길이만 생략 가능

## 3차원 배열

```c
TYPE arr[높이][행][열] // 배열의 이름이 arr, 배열 요소의 자료형이 TYPE인 경우
```

- 여러 개의 2차원 배열이 쌓여있는 형태로 이해하는 것이 합리적
- 행, 열의 크기를 가진 배열이 높이만큼 쌓여있다.

# ch17 포인터의 포인터

## 포인터의 포인터에 대한 이해

### 포인터 변수를 가리키는 더블포인터

- 포인터 변수도 주소 값을 저장하는 **변수**이므로 메모리 공간에 할당된다.
- 포인터의 주소 값을 저장하는 포인터를 더블포인터라고 한다.
- 선언: double \*\*dptr = &ptr;
- 접근: \*dptr = 포인터 변수 ptr 의미 / \*\*dptr = 변수 num 의미

### 포인터 배열과 포인터 배열의 포인터 형

```c
int * arr[20];
```

- 포인터 배열의 이름 arr는 배열의 첫 번째 요소인 arr의 첫 번째 싱글 포인터를 가리키는 포인터 이므로 int형 더블 포인터이다.

## 다중 포인터 변수와 포인터의 필요성

- 삼중 포인터 변수는 이중 포인터 변수를 가리키는 용도로, 이중 포인터의 주소 값을 저장하는 용도로 사용된다.
- 이는 이중 포인터의 원리와 같다
- 포인터가 필요한 이유는 자료구조와 알고리즘에서 중요하게 다룬다
- **하지만 지금은 함수 내에서 함수 외부에 선언된 변수에 접근하는 게 목적**

# ch18 다차원 배열과 포인터의 관계

## 2차원 배열 이름의 포인터 형

### 2차원 배열 이름의 의미와 포인터 연산

```c
int arr2d[3][3]; // 2차원 배열 3행 3열
```

- arr2d는 배열 전체를 의미
- arr2d[0], arr2d[1], arr2d[2]는 각 행을 의미
- arr2d와 arr2d+1의 차이는 행의 길이인 3을 더한 값이다.
  → arr2d가 가리키는 대상이 int형 변수이고, 포인터 연산 시 행의 크기 만큼 증가 및 감소하는 포인터형
  - 2차원 배열의 포인터 변수는 **TYPE (\*name) [size];** 로 선언
  - name은 포인터의 이름, TYPE은 포인터형, size는 행의 크기

### 2차원 배열을 함수의 인자로 전달하기

```c
void SimpleFunc(int (*parr1)[7])
==
voie SimpleFunc(int parr2[][7]
// 이는 매개변수의 영역에서만 동일하고 다른 영역에서는 같지 않다.
```

```c
sizeof(arr) / sizeof(arr[0])
// sizeof(arr)는 배열의 전체크기이고, sizeof(arr[0])은 배열의 가로 길이이므로
// 위 식은 세로길이를 구할 때 자주 이용하는 식이다.
```

### 2차원 배열에서의 arr[i]와 \*(arr+i)의 관계

```c
arr[2][1]=4
== (*(arr+2))[1]=4
== *(arr[2]+1)=4
== *(*(arr+2)+1)=4
```

# ch19 함수 포인터와 void 포인터

## 함수 포인터와 void 포인터

### 함수 포인터의 이해

- 함수의 이름도 함수가 저장된 메모리 공간의 주소 값을 의미 / 상수형 포인터

```c
int SimpleFunc(int num){...}
// 함수의 포인터 형은 반환형 + 매개변수 선언으로 결정
// 반환형이 int이고 매개변수로 int형 변수가 하나 선언된 포인터 형(type)
```

- 함수의 주소 값 저장을 위한 **함수 포인터 변수**를 따로 선언 가능 / 변수형 포인터

### 함수 포인터 변수의 선언

```c
int (*fptr) (int, int);
//반환형이 int, 포인터 이름은 fptr, 매개변수 선언이 int 두 개
```

```c
int SoSimple(int num1, num2){...}
int (*fptr) (int, int); // 함수 포인터 변수 선언
fptr = SoSimple; //함수 포인터 변수에 주소 값 저장
fptr(3,4) == SoSimple(3,4);
```

### 형(TYPE)이 존재하지 않는 void 포인터

```c
void * ptr;
```

- 어떠한 변수의 주소 값이든 다 담을 수 있는 포인터 변수
- 다만 값의 변경이나 참조 불가능
- 주소 값에만 의미를 두고 포인터 형은 나중에 결정할 때 사용 → 메모리의 동적 할당

## main 함수로의 인자 전달

```c
#include <stdio.h>

int main(int argc, char *argv[]){
	int i=0;
	printf("전달된 문자열의 수: %d \n", argc);
	for(i=0; i<argc; i++){
		printf("%d번째 문자열: %s \n", i+1, argv[i]);
	return;
}
```

### argc, char \*argv[]

- argc는 전달된 문자열의 수를 의미

```c
void SimpleFunc(char **arr){...}
==
void SimpleFunc(char *arr[]){...}
```

- 즉 char형 더블 포인터 변수이고, char형 포인터 변수로 이루어진 1차원 배열의 이름을 매개하는 매개변수이다.
