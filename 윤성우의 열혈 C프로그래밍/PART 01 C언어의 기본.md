# PART 01 C언어의 기본

## ch1 이것이 c언어다

### C언어의 장점

1. 절차지향적 특성
2. 이식성이 좋다
3. 고급(High Level) 언어에 비해 좋은 성능을 보인다.

## ch2 프로그램의 기본 구성

### **main함수가 return하는 자료형이 왜 void가 아닌 int인가**

```c
#include <stdio.h>

int main(){
    printf("Hello, world!\n");
    return 0;
}
```

와 같이 자료형을 void로 놓고 return을 빼버리거나 return; 으로 작성해도 되지 않는가?

return 문 사용하는 이유

1. 함수 종료
2. 값의 반환

→ 실제로 경고가 발생하지만 실행은 문제가 없다. 다만 C언어 표준에 위배된다.

호출의 주체가 운영체제인데, 운영체제에게 프로그램의 종료를 알리기 위해서 0을 반환한다.

이때 반환하는 값인 0, 1이 exit status을 의미한다. 이때 0을 반환하면 정상적으로 종료된 경우고, 1을 반환하면 성공적이지 못한 것을 의미한다.

결론적으로? exit status를 제대로 반환하기 위해서, 0과 1인 정수형을 제대로 반환하기 위해서 main 함수의 반환형이 int인 것이다.

표준 함수 = 기본적으로 제공되는 함수

표준 라이브러리 = 표준 함수들의 모임

<aside>
💡 **?CLION에서 한글이 깨지는 현상은 인코딩 형식을 UTF-8에서 x-windows-949 형식으로 바꾸면 된다.**

</aside>

- 인코딩이란 사용자가 입력한 문자나 기호들을 **컴퓨터가 이용할 수 있는 신호**로 만드는 것이고,
- 디코딩은 그 역으로 컴퓨터의 신호를 문자나 기호로 만드는 것
- 처음 영어만 사용할 때는 아스키 코드를 이용해서 했지만, 한국어를 비롯해 다른 나라의 언어들을 추가하다보니 2의 7승으로는 모든 것을 표현할 수 없게 됨
- 한국, 일본, 중국은 1byte로 만족을 못해서 여러 byte를 통해 문자를 표현하는 멀티바이트 인코딩을 사용하였다. 이때도 완성형 인코딩(CP949(MS949, WINDOWS949)로 확장), 조합형 인코딩 등 여러 방식을 사용하였는데, 서로 다른 인코딩 방식을 사용한 프로그램 사이에서 호환성 문제가 발생하였다.
- 그래서 이를 통일하기 위해서 유니코드를 새로 만들었다. 이는 2바이트 숫자와 1:1 매핑하는 방식으로 이 중 하나가 UTF-8이다.
- 하지만 아직 운영체제별로 사용하는 인코딩 방식이
- 마이크로 소프트는 CP949, 맥과 리눅스 UTF-8이므로 깨짐이 발생하는 리스크가 존재한다.

주석 방식 2가지

1. /_ ~ _/
2. // ~

## ch3 변수와 연산자

변수 = 값을 저장할 수 있는 메모리 공간

변수를 선언만 하고 초기화하지 않으면 쓰레기 값이 저장된다.

연산자

후위 연산 시에는 소괄호의 영향을 받지 않고 다음 문장으로 넘어가야만 비로소 값의 증가 및 감소가 이뤄진다

ex) int num2 = (num1- -) + 2;

```jsx
#include <stdio.h>

int main(void){
    int num2;
    int num1 = 10;
    printf("num1: %d \n",num1);
    num2 = (num1--)+2;
    printf("num1: %d \n",num1);
    printf("num2: %d \n",num2);
    return 0;
}
// 결과 값
num1: 10
num1: 9
num2: 12
```

C언어에선 0이 아닌 모든 값을 참으로 간주한다.

다만 주로 true를 의미하는 숫자가 1이고, 참이 return할 때 1이 반환될 뿐이다.

scanf와 구분 연산자의 의문

```jsx
scanf("%d %d", &num1, &num2);
와
scanf("%d, %d", &num1, &num2);
의 차이
```

8진수와 16진수

8진수: 0~7 이후 한자리수 증가 / 0으로 시작하면 8진수로 인식 ex) 012 = (10진수)10

16진수: 0~9~A~F 이후 한자리수 증가 / 0x로 시작하면 16진수로 인식 ex)0xA = (10진수)10

## ch4 정수와 실수의 표현방식

**정수**

MSB(Most Significant Bit): 가장 왼쪽 비트로 양수면 0, 음수면 1

1바이트 기준

00000101 = +5

10000101 ≠ -5

이유는? 두 개를 더했을 때 0이 나오지 않기 때문에

→ 음수와 양수를 바꿔가며 나타내기 위해서 새로운 방법이 필요

→ 2의 보수법 이용 : 1의 보수를 취하고 1을 더하는 것

**실수**

MSB를 제외하고 나머지 비트는 실수를 나타내기 위해서

+-(1.m)\*2^(e-127) 수식을 이용

이를 자세히 이해할 필요는 없고 아주 약간의 오차를 발생 시킨다는 것만 유의

ex) 0.0을 표현하고 싶지만, 2^x은 어떤 방식을 취해도 0이 될 수 없음

→ 이 오차를 **“부동 소수점 오차”** 라고 명명

```c
#include <stdio.h>

int main(void){
	int num = 15; //00000000 00000000 00000000 00001111
	int result1 = num<<1; // 왼쪽으로 한 칸 이동
	int result2 = num<<2; // 왼쪽으로 두 칸 이동
```

왼쪽으로 한 칸 이동하면 정수의 값은 2배가 됨

오른쪽으로 한 칸 이동하면 정수의 값은 1/2배가 됨

```c
// 문제 04-4
// 입력받은 정수의 부호를 바꿔서 출력하는 프로그램을 비트 연산자로만 구현

#include <stdio.h>

int main(void){
    int num1, num2;
    printf("한 개의 정수 입력: ");
    scanf("%d", &num1);
    num2 = ~num1+1;
    printf("결과: %d \n",num2);
    return 0;
}
```

## ch5 상수와 기본 자료형

### 자료형이란?

데이터를 표현하는 기준입니다. 때문에 변수도 상수도 자료형에 근거합니다

자료형이 여러 개인 이유는?

1. 데이터의 표현 방식이 다르고, 최소한 둘 이상 (정수 자료형, 실수 자료형)이 필요하다
2. 메모리 공간의 적절한 사용을 위해서 다양한 크기의 자료형을 사용

**정수의 경우**

CPU가 가장 연산하기 좋은 자료형은 int여서, int보다 작은 자료형은 int로 형변환함

<> 하지만 데이터의 양이 많아서 연산속도보다 데이터의 크기를 줄이는 게 중요한 상황에는 char, short 자료형 사용

**실수의 경우**

CPU가 가장 처리하기 좋은 자료형은 double

float, double, long double 사용하는 경우를 결정 짓는 요인은 정밀도

**문자의 경우**

아스키 코드에 저장된다. 이때 저장하는 데이터의 형태가 char형인데,

이는 연산을 필요로 하지 않기 때문에 char형이 더 적합하다.

이름이 없는 상수: 리터럴 상수 or 리터럴

리터럴: 글자 그대로의

이름을 지니는 상수: 심볼릭 상수 / const 상수

- 선언과 동시에 초기화 필수
- 모두 대문자로 표시하고, 둘 이상의 단어를 연결할 때는 \_를 이용해 구분

**정수의 승격**

정수보다 크기가 작은 데이터형끼리 연산하는 경우에 연산 속도가 가장 빠른 int형으로 승격되는 것을 의미한다.

피연산자의 자료형 불일치로 발생하는 자동 형 변환

- 데이터의 손실을 최소화하는 방향으로 진행
  - int → long → long long → float → double → long double
      <aside>
      💡 long long보다 float가 바이트가 작은데 왜 방향이 이런지?
      an: 손실이 발생할 수는 있으나 실수형에서 정수형으로의 전환은 무조건 소수부의 손실이 생기기 때문에 정수형 → 실수형 방향으로 자동 형 변환이 일어난다.
      
      </aside>


**명시적 형 변환**

- 강제로 일으키는 형 변환

```c
# include <stdio.h>

int main(void) {
	int num1 = 3, num2 = 4;
	double divResult;
	divResult = num1/num2;
	printf("나눗셈 결과: %f \n", divResult);
	return 0;
}
```

num1/num2는 int형이므로 값이 0이 돼서 divResult의 값은 0.000000이 된다.

하지만 divResult = (double)num1/num2; 이라고 수정하면

명시적 형 변환이 먼저 연산되어서 0.75로 출력된다.

## ch 6 print 함수와 scanf 함수 정리하기

- **printf 함수란?**
  - 문자열을 출력하는 함수
  - 특수 문자의 필요성
    - 특수 문자 안의 특수 문자를 나타내거나, 다른 의미를 표현하기 위함
      - \n: 개 행 문자, \”: 큰 따옴표 출력
  - printf 함수의 서식 지정
    - 출력 양식을 지정해두고 출력을 하는 것을 의미
    - 서식 문자의 종류와 의미
      - 정수 관련
        - %d: 부호있는 10진수
        - %o: 8진수, %#o로 표현하면 0~으로 표현
        - %x: 16진수, %#x로 표현하면 0x~으로 표현
      - 실수 관련
        - %f: 10진수 방식의 부동소수점 실수 표현
        - %e: 지수 형태의 실수 표현
      - 문자열 관련
        - %s: 문자열 표현
      - 필드 폭 지정
        - %8d: 필드 폭을 8칸 확보하고, 오른쪽 정렬해서 출력
        - %-8d: 필드 폭을 8칸 확보하고, 왼쪽 정렬해서 출력
- scnaf 함수란?
  - prinf 함수의 서식 문자와 대체로 동일하지만 몇 가지 다른 점이 있다.
    - float, double, long double의 데이터 출력에 사용되는 서식 문자는 %f, %f, %lf 이다.
    - 위 자료형의 입력에 사용되는 서식 문자는 %f, %lf, %lf이다.

## **ch9 C언어의 핵심! 함수!**

**변수**

- 전역변수
  - 프로그램의 시작과 동시에 메모리 공간에 할당되어 종료 시까지 존재
  - 별도의 값으로 초기화하지 않으면 0으로 초기화
  - 프로그램 전체 영역 어디서든 접근이 가능
  - 프로그램을 복잡하게 만들기 때문에 가급적 제한해서 사용
- 지역변수
  - 스택이라는 메모리 영역에 할당
  - 접시에 쌓듯이 할당
  - 매개변수도 지역변수
  - 해당 선언문이 실행될 때 메모리 공간에 할당되었다가, 선언문이 존재하는 함수가 반환을 하면 메모리 공간에서 소멸
- 둘의 차이는 메모리 상에 존재하는 기간, 변수에 접근할 수 있는 범위
- static 변수(지역변수)
  - 전역변수와 같은 특성을 가지고 있지만, 접근할 수 있는 범위가 제한되어있는 변수
- register 변수 (지역변수)
  - cpu 내에 레지스터라는 메모리 공간에 저장되는 변수
  - 접근 속도가 가장 빠름

**재귀함수**

- 자기 자신을 다시 호출하는 함수
- 자료구조나 알고리즘의 어려운 문제를 단순화하는데 사용하는 중요한 무기
  - 반복되는 함수를 코드로 표현하는 방법
  - 탈출 조건
  - ex) factorial을 함수로 나타내는 방법
  - f(n) = n\*f(n-1)…n≥1, 1…n-0

```c
#include <stdio.h>

int Factorial(int n){
	if(n==0)
		return 1;
	else{
		return n * Factorial(n-1);
	}
}
int main(void){
	printf("9! = %d \n", Factorial(9));
	return 0;
}
```
