# PART 02 포인터와 배열의 시작

# ch11 1차원 배열

## 배열의 이해와 선언, 초기화

### 배열이란?

- 다수의 데이터를 저장하고 처리하는 경우에 유용하게 사용할 수 있는 것

### 1차원 배열의 선언에 필요한 것

- 배열 이름, 자료형, 길이 정보

```c
int Arr[3]; // 자료형, 배열 이름, 길이 정보
```

- 이때 배열의 길이 정보를 상수로 지정

### 1차원 배열의 접근

```c
int Arr[0]= 10; // 배열의 첫 번째에 0을 저장
```

### 배열을 초기화하는 3가지 방법

```c
int Arr[5]= {1, 2, 3, 4, 5}; // 가장 일반적인 형태로, 순차적으로 저장
int Arr[ ]= {1, 2, 3, 4, 5}; // 자동으로 배열의 길이 정보 저장
int Arr[5]= {1, 2}; // 1, 2 뒤의 3자리에는 0을 저장
```

## 배열을 이용한 문자열 변수의 표현

### char형 배열의 문자열 저장과 널(null) 문자

- 문자열을 저장할 때는 마지막에 \0(escape sequence, null)이 같이 저장되므로 이를 고려해서 배열의 길이를 결정해야한다.
- 널 문자의 아스키 코드 값은 0이다. 이를 출력하면 아무런 출력이 발생하지 않는다
- 공백 문자의 아스키 코드는 32로, 이는 null과 엄연히 다르다

### scanf 함수를 이용한 문자열의 입력

- 문자열을 출력하는 printf 함수와 같이 문자열을 입력 받는 scanf함수 역시 %s 서식문자를 사용

```c
scanf("%s", str); // str이 배열인 경우
scanf("%s", &str); // str이 변수인 경우
```

### 문자열과 널

- scanf함수를 통해 받은 문자열의 끝에도 널 문자가 자동으로 삽입

**→ 널 문자가 존재하면 문자열이고, 널 문자가 존재하지 않으면 문자열이 아니다**

- 문자열의 끝에 널(null) 문자가 필요한 이유
  - 문자열의 끝을 표시하기 위함이다.
  - str[0]이 문자열의 시작이고, 문자열의 끝에는 널 문자가 삽입되어 있다고 인식한다.

# ch12 포인터의 이해

## 포인터란 무엇인가?

### 주소 값의 저장을 목적으로 선언되는 포인터 변수

- 변수를 저장할 때, 저장하는 변수의 크기에 따라 메모리를 할당한다.
- 하지만 메모리에서 저장된 변수의 주소를 반환할 때는 시작 주소 만을 가지고 표현한다.
- 즉 포인터 변수란 **메모리의 주소 값을 저장하기 위한 변수**다.
  - 참고로 포인터에는 변수 형태의 포인터와 상수 형태의 포인터가 존재

### 포인터 변수와 &연산자에 대한 개요

```c
int main(void){
	int num=7;
	int *pnum; //pnum = 포인터 변수의 이름, int * = int형 포인터 변수
	pnum = &num; // &연산자 = 피연산자의 주소 값을 반환하는 연산자
}
```

- 운영체제 시스템의 크기와 주소 값의 크기가 같다. ex)32bit 시스템 = 4바이트, 64bit 시스템 =8바이트
- 포인터 변수의 크기도 주소 값의 크기와 같다.
- → 운영체제 시스템의 크기 = 포인터 변수의 크기

### 포인터 변수 선언하기

```c
type * // type형 포인터
type *ptr; // type형 변수의 주소 값을 저자하는 포인터 변수 ptr의 선언
```

- **포인터 형(Type)**
  - int, char, double 을 자료형이라고 하듯이 int \*, char**, double**을 포인터 형이라고 부른다.
  - 포인터 기반의 메모리 접근 기준을 정확히 하기 위함
  - 포인터 형이 존재하지 않으면 \*연산을 통한 메모리의 접근이 불가능함

```c
int main(void){
	double num 3.14;
	int *pnum = &num;
	printf("%d", *pnum);
}
// 위와 같이 작성시, int형 포인터 변수 pnum이 double형 변수 num을 가리키게 되면서
// 8바이트의 데이터를 4바이트로 해석하면서 전혀 예측할 수 없는 결과를 도출한다.
```

## &연산자와 \*연산자

### &연산자

- 피연산자의 주소 값을 반환하는 연산자
  - 피연산자는 **변수**, 상수는 피연산자 X

### \*연산자

- \*연산자는 포인터가 가리키는 메모리 공간에 접근/참조하는 연산자

### **포인터의 이해**

```c
int main(void){
	int num = 10;
	int *ptr1 = &num;
	int *ptr2 = ptr1;

	(*ptr1)++;
	(*ptr2)++;
	printf("%d \n", num);
	return 0;
}
// 출력값: 12
```

```c
int main(void){
	int num = 10;
	int *ptr1 = &num;
	int *ptr2 = &ptr1;

	(*ptr1)++;
	(*ptr2)++;
	printf("%d \n", num);
	return 0;
}
// 출력값: 11
// 출력값 11이 되는 이유
// &은 주소 값을 반환하는 연산자로, *ptr1에 저장된 num의 주소 값이 아닌, *ptr1 자체의
// 주소 값이 저장되므로 num은 1만 증가하여 11이 출력된다.
```

```c
int main(void){
	int num = 10;
	int *ptr1 = &num;
	int *ptr2 = *ptr1;

	(*ptr1)++;
	(*ptr2)++;
	printf("%d \n", num);
	return 0;
}
// 출력값: 11, 에러 발생
// *ptr1은 num의 주소값에 저장하는 포인터 변수이므로, *ptr2에는 num의 값 10이 초기화되는
// 것이다.
// int *ptr = 10; 이므로 어떤 주소인지 모르는 곳으로 접근하므로 에러가 발생한다.
```

### 잘못된 포인터의 사용과 널 포인터

```c
int main(void){
	int *ptr;
	*ptr=200;
}
```

- 포인터 변수를 선언만 하고 초기화하지 않으면 포인터 변수는 쓰레기 값으로 초기화
- 포인터 변수가 가리키는 메모리 공간이 매우 중요한 위치라면 시스템 전체에 문제 발생
- 그래서 잘못된 메모리의 접근을 미연에 방지

```c
int main(void){
	int *ptr=0;
	int *ptr2=NULL;
}
```

- 우선 선언만 하고 나중에 유효한 주소 값을 넣을 경우 위처럼 0 또는 NULL 값으로 초기화
- 이를 **널 포인터**라고 부른다.

# ch13 포인터와 배열

### 포인터와 배열의 관계

배열의 이름은 배열의 시작 주소 값을 의미하는 포인터

포인터란?

- 주소 값에 대한 정보를 가지고 있음
- 포인터 형에 대한 정보를 가지고 있음

```c
int *ptr;
int num;
ptr= &num;
// ptr은 num의 주소값을 의미하는 정수 값이 된다.

int arr[3];
// arr -> arr[0]번째 주소값을 가리키는 정수 값이 된다.
```

- 포인터 변수는 다른 주소 값을 할당할 수 있고, **변수**이다.
- 배열의 경우 arr[0]을 제외하곤 다른 값을 할당할 수는 없고, **상수**이다.
- → *ptr / int형 변수라는 의미를 포함 — arr 역시 *arr라 표현할 수 있고, int형 변수라는 의미 포함
- \*arr 는 결국 arr[0] 값을 의미함
- 이는 *ptr[0], *ptr[1], \*ptr[2] 연산도 가능하다는 것을 의미한다.

### 포인터 연산

- 증가와 감소 연산 가능
- 일반적인 증가와 감소 연산과 다르게 포인터에서는,

```c
type *ptr;
1+ or 1- -> 1이 증가/감소가 아니라 sizeof(type)의 값만큼 증가 감소 // int면 4, double이면 8
```

- **arr[i] == \*(arr+i)**

```c
printf("%d %d %d \n", *(ptr+0), *(ptr+1), *(ptr+2));
==
printf("%d %d %d \n", ptr[0], ptr[1], ptr[2]));
```

### 상수 형태의 문자열을 가리키는 포인터

```c
char str1[ ] = "My String"; // 문자열이 저장된 배열, 변수 성향의 문자열 -> 변경 가능
char *str2 = "Your String"; // 자동할당된 문자열의 주소 값을 저장, 상수 성향의 문자열 -> 변경x
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0aaf4a74-921a-401b-8ef7-79a743f1e4df/350f8489-b241-40ae-be4e-8340d33d8840/Untitled.png)

```c
int main(void){
	char *str = "Your team";
	str = "Our team"; //의미 있는 문장
}
// Your team 문자열이 자동 할당된 문자열의 주소 값에서 Our team 문자열의 주소 값으로 바뀜
```

```c
int main(void){
	char str[] = "Your team";
	str = "Our team"; //의미 없는 문장
}
// 배열 안에 주소 값이 아닌 Your team 문자열 자체가 저장된 것이므로 상수처럼 간주하여 다른 상수를
// 재지정 불가하다
```

### 포인터 배열

```c
int main(void){
	int num1=10, num=20, num3=30;
	int * arr[3]={&num1, &num2, &num3);
	printf("%d \n", *arr[0]);
	printf("%d \n", *arr[1]);
	printf("%d \n", *arr[2]);
	return;
}
```

# ch14 포인터와 함수에 대한 이해

### 함수의 인자로 배열 전달

- main 함수에 선언된 변수 num을 새로운 함수 fct에 그대로 전달할 수 없다
- 그래서 매개변수의 형태로 **복사**해서 사용한다.
- 하지만 배열은 매개변수로 전달조차 불가능하다.
- 그래서 배열의 **주소 값을 전달**하는 방법으로 num에 바로 접근할 수 있다.

```c
void SimpleFunc(int *param){
	printf("%d, %d", param[0], param[1]);
}
int main(void){
	int arr[3] = {1,2,3};
	SimpleFunc(arr);
}
// 배열의 값이 아닌 주소값이 전달되어서 접근/참조 가능하다
```

```c
void ShowArayElem(int *param, int len) {...}
==
void ShowArayElem(int param[], int len) {...}
// 매개변수의 선언에서는 int *param과 int param[]이 동일한 선언이다.
// 하지만 그 이외의 영역에서는 int *ptr의 선언을 int ptr[]으로 대체할 수 없다.
```

### Call-by-vaule vs Call-by-reference

Call-by-vaule

- 단순히 값을 전달하는 형태의 함수 호출
- 함수 외부에 선언된 변수에 접근이 불가능

Call-by-reference

- 메모리의 접근에 사용되는 주소 값을 전달하는 형태의 함수 호출
- 함수 외부에 선언된 변수에 접근 가능

```c
int main(void){
	int num;
	scanf("%d", &num);
}
// 변수 num 앞에 &연산자를 붙이는 이유는?
// 변수의 주소값을 알아야 하기 때문이다.
int main(void){
	char str[30];
	scanf("%s", str);
}
// 배열 이름 str 앞에 &연산자를 붙이지 않는 이유는?
// 배열의 이름 자체가 이미 배열의 첫번째 요소의 주소값을 의미하기 때문이다.
```

### 포인터 대상의 const 선언

```c
const int *ptr = &num; // 포인터 변수 ptr이 가리키는 변수에 저장된 값을 변경하지 못한다.
int *const ptr = &num; // 포인터 변수 ptr이 가리키는 대상을 변경하지 못한다.
const int * const ptr = &num; // 동시에 두 가지도 가능하다.
```

const 선언이 갖는 의미

- const는 바뀌면 안되는 상수를 절대 바꾸지 않게 하여서 코드의 안정성을 높여야 한다.
- 되도록 const를 넣을 수 있는 경우라면 최대한 넣는 게 좋다.
