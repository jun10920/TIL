# Section09\_상속

## 상속 관계

- 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 하는 것
- extends 키워드를 사용
- 용어 정리
  - 부모 클래스 (슈퍼 클래스)
  - 자식 클래스 (서브 클래스)
- 단일 상속
  - 자바는 다중 상속을 지원하지 않는다.
  - 여러 개의 상속을 받은 구조를 다이아몬드 구조라고 부른다
    - 이는 클래스 계층 구조의 복잡성을 늘리기 때문에 자바에서는 불가능
  - 하지만 인터페이스의 다중 구현을 통해 이러한 문제를 피해서 같은 기능을 구현

### 상속과 메모리 구조

- 상속을 받는 자식 클래스의 인스턴스를 생성 시
  - 외부에서는 하나의 인스턴스를 생성하는 것 같지만 내부에선 **부모와 자신이 모두 생성**
  - 메모리에는 자식 클래스 + 부모 클래스가 합쳐진 만큼의 메모리가 할당 된다.
  - 사람이 이해하기 쉽게 상속(물려받는다)라고 표현하는 것
- 상속을 받은 자식 클래스의 메서드 호출 시
  - **우선 호출 받은 클래스의 메서**드부터 순회
  - **자식에 없는 경우 상위 부모 클래스를 순회**한다

### 상속과 기능 추가

- 기능을 추가할 때 부모 클래스에만 추가하여 중복을 줄일 수 있다.

## 상속과 메서드 오버라이딩

- 부모에게 상속 받은 기능을 자식이 재정의 하는 것
  ```python
  public class ElectricCar extends Car{
      @Override
      public void move() {
          System.out.println("전기차를 고속으로 이동합니다");
      }

      public void charge() {
          System.out.println("충전합니다");
      }
  }
  ```
- @Override
  - @이 붙은 부분은 애노테이션이라고 부른다
  - 이는 프로그램이 읽을 수 있는 특별한 주석이라고 생각하면 된다.
  - 이 애노테이션은 상의 클래스의 메서드를 오버라이드 하는 것을 의미
    - 컴파일러는 이 애노테이션을 보고 오바라이드 되었는지 확인
    - 오버라이드 조건을 만족하지 않는 경우 컴파일 에러를 발생
      - 실수로 오버라이드 못하는 경우를 방지
- 오버라이드 하는 경우 메모리
  - 호출한 클래스에서 이미 해당 메서드를 찾았기 때문에 굳이 상위 클래스에서 메서드를 찾지 않는다.

## 오버로딩과 오버라이딩

- 오버로딩
  - 과적의 의미로, 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 의미한다..
- 오버라이딩
  - 상속에서 같은 이름의 메서드를 재정의하는 것을 의미한다.
  - 라이드가 넘어간다는 의미로, 기존 기능을 넘어서 새로운 기능으로 넘어간다(덮는다)고 이해하면 된다.
  - 실무에서 메서드 오버라이딩, 메서드 재정의 둘 다 사용한다.

## 메서드 오버라이딩 조건

- 메서드 이름
  - 메서드 이름이 동일해야 한다
- 메서드 매개변수(파라미터)
  - 매개변수(파라미터) 타입, 순서, 개수가 동일해야 한다.
- 반환 타입
  - 반환 타입이 동일해야 한다. 단, 하위 클래스 타입은 허용된다.
- 접근 제어자
  - 상위 클래스의 메서드의 접근 제어자보다 오버라이딩한 메서드의 접근 제어자가 더 제한적이면 안된다.
- 예외
  - 오바리이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws 선언 할 수 없다.
- static, final, private 메서드는 오버라이딩 될 수 없다.
  - static
    - 클래스 레벨에서 접근하는 메서드이기 때문에, 오버라이드는 인스턴스 영역에서 주고 받는 것이라 무관하다
  - final
    - 재정의를 금지한다
  - private
    - 한 클래스 내부에서만 사용하려고 제한한 것이므로 불가능하다
- 생성자 오버라이딩
  - 생성자는 오버라이딩 할 수 없다.

## 상속과 접근 제어

- UML 표기법에서의 접근 제어자
  - - public
  - # protected
  - ~ default
  - - private
- 상속을 받더라도 부모 클래스와 자식클래스는 분리되어서 하나의 주소에 생성이 된다.
  - 그래서 부모 입장에서는 외부에서 호출한 것과 같기 때문에 접근 제어를 받는다

## super - 부모 참조

- this는 자기 자신의 참조를 의미한다.
  - 생략 가능하다 / this가 없더라도 현재 클래스에서 먼저 찾고 이후에 부모 클래스를 찾기 때문이다.
- super는 부모 클래스의 참조를 뜻한다
  - 필드나 메서드 이름이 같지만 super 클래스를 통해서 부모 클래스에 있는 기능을 사용할 수 있다 .

## super - 생성자

- 자식 클래스를 생성하면 부모 클래스도 같이 생성되므로 생성자도 모두 호출된다
- **상속 관계에서는 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출**
  ```java
  public class ClassB {
      private int num;
      public ClassB(int num) {
          this.num = num;
      }
  }
  ```
  ```java
  public class ClassC extends ClassB{
      private int num;
      public ClassC(int num) {
          super(10); //기본 생성자는 생략가능, 하지만 생성자가 정의된 경우 불가능
          this.num = num;
      }
  }
  ```
- 자식 클래스의 생성자의 첫 줄에는 super()를 통해서 부모 클래스의 생성자를 호출해야 한다.
- 첫 줄에서 부모의 생성자를 호출하기 때문에 가장 상위의 부모 클래스부터 초기화가 이루어진다.
